using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;

namespace CLUNL.Localization
{
    /// <summary>
    /// An interface for objects that will use Language.
    /// </summary>
    public interface ILocalized
    {
        /// <summary>
        /// Apply current language.
        /// </summary>
        void ApplyLanguage();
    }
    /// <summary>
    /// Represent a language resource collection.
    /// </summary>
    public class Language
    {
        private const string Locales = "Locales";
        internal const string EqualSymbol = "=";
        private const string DefaultLang = "en-US.lang";
        private const string DefaultRegion = "en-US";
        internal const string GeneratorPrefix = "; Generated By CLUNL.Localization";
        static LanguageDefinition LanguageStrings = new LanguageDefinition();
        /// <summary>
        /// Enumerate all key-value pairs.
        /// </summary>
        /// <returns></returns>
        public IEnumerator<KeyValuePair<string, string>> EnumerateValues()
        {
            foreach (var item in LanguageStrings)
            {
                yield return item;
            }
        }
        /// <summary>
        /// Set a value. 
        /// </summary>
        /// <param name="K"></param>
        /// <param name="V"></param>
        public void SetValue(string K, string V)
        {
            LanguageStrings[K] = V;
        }
        static bool isInited = false;
        /// <summary>
        /// If current language object is initialized with language files.
        /// </summary>
        /// <returns></returns>
        public static bool IsInited() => isInited;
        /// <summary>
        ///  Init languages with given settings file and a product name.
        /// </summary>
        /// <param name="SettingsFileName"></param>
        /// <param name="ProductName"></param>
        public static void Init(string SettingsFileName, string ProductName)
        {
            Init(ObtainInstalled(SettingsFileName, ProductName));
        }
        static string configuration = null;
        static string ObtainInstalled(string SettingFileName, string ProductName = "CLUNL")
        {
            if (configuration != null)
            {
                return configuration;
            }
            configuration = DefaultRegion;
            if (File.Exists("./" + SettingFileName))
            {
                configuration = File.ReadAllLines("./" + SettingFileName)[0];
            }
            else
            {
                var p0 = Path.Combine(new FileInfo(typeof(Language).Assembly.Location).Directory.FullName, SettingFileName);
                if (File.Exists(p0))
                {
                    configuration = LoadFromFile(p0);
                }
                else
                {
                    var config = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
                    var Configurations = Path.Combine(config, ProductName);
                    if (!Directory.Exists(Configurations)) Directory.CreateDirectory(Configurations);
                    var p1 = Path.Combine(Configurations, SettingFileName);
                    if (File.Exists(p1))
                    {
                        configuration = LoadFromFile(p1);
                    }
                    else
                    {
                        File.WriteAllText(p1, CultureInfo.CurrentUICulture.Name);
                    }
                }
            }
            string LoadFromFile(string p)
            {
                return File.ReadAllLines(p)[0];
            }
            return configuration;
        }
        /// <summary>
        /// Initialize language with given language code, eg: en-US.
        /// </summary>
        /// <param name="PreferredLanguageCode"></param>
        public static void Init(string PreferredLanguageCode)
        {
            isInited = true;
            //CultureInfo.CurrentUICulture.Name -> en-US
            var d = new FileInfo(typeof(Language).Assembly.Location).Directory;
            var langfile = Path.Combine(d.FullName, Locales, DefaultLang);
            if (File.Exists(langfile))
                LoadLanguageFile(langfile);
            if (PreferredLanguageCode == DefaultRegion)
                return;
            langfile = Path.Combine(d.FullName, Locales, PreferredLanguageCode + ".lang");
            if (File.Exists(langfile))
                LoadLanguageFile(langfile);
        }
        /// <summary>
        /// Save current definitions into a file.
        /// </summary>
        /// <param name="TargetFile"></param>
        public static void SaveCurrentDefinition(FileInfo TargetFile)
        {
            TargetFile.Delete();
            var sw = TargetFile.CreateText();
            sw.WriteLine(GeneratorPrefix);
            foreach (var item in LanguageStrings)
            {
                sw.Write(item.Key);
                sw.Write(EqualSymbol);
                sw.WriteLine(item.Value);
                sw.Flush();
            }
            sw.Close();
        }
        /// <summary>
        /// Load a language file and merge it into current definitions.
        /// </summary>
        /// <param name="FilePath"></param>
        public static void LoadLanguageFile(string FilePath)
        {
            var contents = File.ReadAllLines(FilePath);
            LoadFromStringArray(contents);
        }
        /// <summary>
        /// Load a language from a string array and merge it into current definitions.
        /// </summary>
        /// <param name="contents"></param>
        public static void LoadFromStringArray(string[] contents)
        {
            foreach (var item in contents)
            {
                var pitem = item.Trim();
                if (pitem.StartsWith("#") || pitem.StartsWith(";") || pitem.StartsWith("//"))
                {
                    continue;
                }
                else
                {
                    var index = pitem.IndexOf(EqualSymbol);
                    if (index > 0)
                    {
                        var pairName = pitem.Substring(0, index);
                        var pairContent = pitem.Substring(index + 1);
                        if (!LanguageStrings.ContainsKey(pairName))
                            LanguageStrings.Add(pairName, pairContent);
                        else LanguageStrings[pairName] = pairContent;
                    }
                }
            }
        }
        /// <summary>
        /// Load a language from a string and merge it into current definitions.
        /// </summary>
        /// <param name="content"></param>
        public static void LoadFromString(string content)
        {
            using (StringReader stringReader = new StringReader(content))
            {
                string item = null;
                while ((item = stringReader.ReadLine()) != null)
                {
                    var pitem = item.Trim();
                    if (pitem.StartsWith("#") || pitem.StartsWith(";") || pitem.StartsWith("//"))
                    {
                        continue;
                    }
                    else
                    {
                        var index = pitem.IndexOf(EqualSymbol);
                        if (index > 0)
                        {
                            var pairName = pitem.Substring(0, index);
                            var pairContent = pitem.Substring(index + 1);
                            if (!LanguageStrings.ContainsKey(pairName))
                                LanguageStrings.Add(pairName, pairContent);
                            else LanguageStrings[pairName] = pairContent;
                        }
                    }
                }
            }
        }
        /// <summary>
        /// Find a string with given fallback using string.Format(...).
        /// </summary>
        /// <param name="Key"></param>
        /// <param name="Fallback"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public static string FindF(string Key, string Fallback = "", params string[] parameters)
        {
            var os = Find(Key, Fallback);
            return string.Format(os, parameters);
        }

        /// <summary>
        /// Find a string with given fallback using string.Format(...).
        /// </summary>
        /// <param name="Key"></param>
        /// <param name="Fallback"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public static string FindF(string Key, string Fallback = "", params object[] parameters)
        {
            var os = Find(Key, Fallback);
            return string.Format(os, parameters);
        }
        /// <summary>
        /// Find a string with given fallback.
        /// </summary>
        /// <param name="Key"></param>
        /// <param name="Fallback"></param>
        /// <returns></returns>
        public static string Find(string Key, string Fallback = "")
        {
            if (!LanguageStrings.ContainsKey(Key))
                return Fallback;
            else return LanguageStrings[Key].Replace("\\r", "\r");
        }
    }
}
